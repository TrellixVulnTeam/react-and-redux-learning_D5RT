{"ast":null,"code":"// maintains a list of posts from the json api\nexport default ((state = [], action) => {\n  // a reducer must return something besides 'undefined'\n  // a reducer must only ever use it's own arguments, never venturing outside of itself\n  // it is pure, only things you have already made it uses\n  // state does not mutate (although this is false, it depends, it's just best practice)\n  // basically if your state is the same or not the same and you return it, react will not rerender\n  // redux will not register it even if it has changed because it looks like the same state var\n  // if the action is a 'FETCH_POSTS' return the payload\n  // if(action.type === 'FETCH_POSTS'){\n  //     return action.payload;\n  // }\n  // otherwise return the previous state (because we have to return something)\n  // return state;\n  // Frequently a switch statement is used instead in a reducer instead\n  switch (action.type) {\n    case 'FETCH_POSTS':\n      return action.payload;\n\n    default:\n      return state;\n  }\n}); // this runs with initialisation once when the browser loads up\n// this is the default state ([])\n// our reducers run, then render() then componentDidMount()\n// data is fetched by the reducer\n// the reducer sees the action 'FETCH_POSTS'\n// it returns action.payload\n// then react sees the new data, and rerenders itself\n// the postList component is then rerendered\n// mapStateToProps is called again, with a new value of state.posts\n// then props.posts is going to show up inside our component (render())\n// we get the entire response object back, but we are just interested in the data portion\n// so in the index.js file in actions, we adjust the response to just bring back the data","map":{"version":3,"sources":["/Users/james_cameron-mowat/Documents/React Apps/blog/src/reducers/postsReducer.js"],"names":["state","action","type","payload"],"mappings":"AAAA;AACA,gBAAe,CAACA,KAAK,GAAG,EAAT,EAAaC,MAAb,KAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,UAAOA,MAAM,CAACC,IAAd;AACI,SAAK,aAAL;AACI,aAAOD,MAAM,CAACE,OAAd;;AACJ;AACI,aAAOH,KAAP;AAJR;AAMH,CAtBD,E,CAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// maintains a list of posts from the json api\nexport default (state = [], action) => {\n    // a reducer must return something besides 'undefined'\n    // a reducer must only ever use it's own arguments, never venturing outside of itself\n    // it is pure, only things you have already made it uses\n    // state does not mutate (although this is false, it depends, it's just best practice)\n    // basically if your state is the same or not the same and you return it, react will not rerender\n    // redux will not register it even if it has changed because it looks like the same state var\n\n    // if the action is a 'FETCH_POSTS' return the payload\n    // if(action.type === 'FETCH_POSTS'){\n    //     return action.payload;\n    // }\n    // otherwise return the previous state (because we have to return something)\n    // return state;\n\n    // Frequently a switch statement is used instead in a reducer instead\n    switch(action.type){\n        case 'FETCH_POSTS':\n            return action.payload;\n        default: \n            return state;\n    }\n};\n\n// this runs with initialisation once when the browser loads up\n// this is the default state ([])\n// our reducers run, then render() then componentDidMount()\n// data is fetched by the reducer\n// the reducer sees the action 'FETCH_POSTS'\n// it returns action.payload\n// then react sees the new data, and rerenders itself\n// the postList component is then rerendered\n// mapStateToProps is called again, with a new value of state.posts\n// then props.posts is going to show up inside our component (render())\n// we get the entire response object back, but we are just interested in the data portion\n// so in the index.js file in actions, we adjust the response to just bring back the data"]},"metadata":{},"sourceType":"module"}